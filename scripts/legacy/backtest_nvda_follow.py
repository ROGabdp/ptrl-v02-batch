#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
================================================================================
NVDA å°ˆå±¬è·Ÿå–®å›æ¸¬è…³æœ¬
================================================================================
å°ˆé–€é‡å° NVDA çš„å›æ¸¬ï¼Œæ”¯æ´è‡ªè¨‚æ—¥æœŸç¯„åœã€å¹´åº¦è³‡é‡‘æ³¨å…¥ã€ä¿¡å¿ƒåº¦åˆ†ç´šè²·å…¥ã€‚

åŠŸèƒ½:
- å›æ¸¬èµ·å§‹æ—¥æ³¨å…¥ $2,400ï¼Œæ¯å¹´ç¬¬ä¸€å€‹äº¤æ˜“æ—¥å†æ³¨å…¥ $2,400
- AI ä¿¡å¿ƒåº¦åˆ†ç´šè²·å…¥ (>95%: 25%, 90-95%: 15%, <90%: ä¸è²·)
- å¸‚å ´æ¿¾ç¶² (Nasdaq 120MA + DC20 çªç ´)
- åœæåœåˆ©æ©Ÿåˆ¶ (-8% / 15%+8%~9%)
- è¼¸å‡ºè·Ÿå–®ç¸½çµæª”æ¡ˆ

ä½œè€…ï¼šPhil Liang (Generated by Gemini)
æ—¥æœŸï¼š2026-01-18
================================================================================
"""

import os
import sys
import json
import argparse
import torch
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime
from tqdm import tqdm

if sys.platform == 'win32':
    sys.stdout.reconfigure(encoding='utf-8')

plt.rcParams['font.sans-serif'] = ['Microsoft JhengHei', 'SimHei', 'Arial Unicode MS']
plt.rcParams['axes.unicode_minus'] = False

from train_us_tech_buy_agent import (
    load_or_update_local_csv,
    calculate_features,
    BENCHMARK, FEATURE_COLS, VAL_RANGE, MODELS_PATH
)

from stable_baselines3 import PPO


# =============================================================================
# å›æ¸¬åƒæ•¸
# =============================================================================
TICKER = "NVDA"
DEFAULT_START, DEFAULT_END = VAL_RANGE

# è³‡é‡‘æ³¨å…¥
YEARLY_INJECTION = 2400

# ä¿¡å¿ƒåº¦é–€æª»èˆ‡è²·å…¥æ¯”ä¾‹
CONFIDENCE_HIGH = 0.95      # > 95% â†’ è²·å…¥ 25%
CONFIDENCE_LOW = 0.90       # 90% - 95% â†’ è²·å…¥ 15%
BUY_RATIO_HIGH = 0.25       # > 95%
BUY_RATIO_LOW = 0.15        # 90% - 95%

# é¢¨éšªç®¡ç†åƒæ•¸
HARD_STOP_PCT = -0.08
TRAILING_ACTIVATION = 0.20
HIGH_PROFIT_THR = 0.25
CALLBACK_BASE = 0.08
CALLBACK_HIGH = 0.17

BASE_OUTPUT_DIR = "backtest_results_nvda"


# =============================================================================
# æ¨¡å‹è¼‰å…¥
# =============================================================================
def load_model_manifest(models_path: str) -> dict:
    manifest_path = os.path.join(models_path, "model_manifest.json")
    if not os.path.exists(manifest_path):
        return None
    with open(manifest_path, 'r', encoding='utf-8') as f:
        return json.load(f)


def load_ticker_model(ticker: str, manifest: dict) -> PPO:
    if ticker not in manifest.get("tickers", {}):
        return None
    model_path = manifest["tickers"][ticker]["model_path"]
    if not os.path.exists(model_path):
        return None
    return PPO.load(model_path, device="cpu")


def get_action_confidence(model: PPO, obs: np.ndarray) -> tuple:
    obs_tensor = torch.as_tensor(obs.reshape(1, -1), dtype=torch.float32)
    with torch.no_grad():
        distribution = model.policy.get_distribution(obs_tensor)
        probs = distribution.distribution.probs.numpy()[0]
        action, _ = model.predict(obs, deterministic=True)
        return int(action), float(probs[1])


# =============================================================================
# å¸‚å ´æ¿¾ç¶²è¨ˆç®—
# =============================================================================
def prepare_market_filter(benchmark_df: pd.DataFrame, ticker_df: pd.DataFrame) -> pd.DataFrame:
    """è¨ˆç®—å¸‚å ´æ¿¾ç¶²æŒ‡æ¨™"""
    # Nasdaq 120MA
    benchmark_df = benchmark_df.copy()
    benchmark_df['Nasdaq_120MA'] = benchmark_df['Close'].rolling(120).mean()
    benchmark_df['Nasdaq_Above_120MA'] = benchmark_df['Close'] > benchmark_df['Nasdaq_120MA']
    
    # å€‹è‚¡ 20 æ—¥å”å…¶å®‰é€šé“
    ticker_df = ticker_df.copy()
    ticker_df['DC20_High'] = ticker_df['High'].rolling(20).max().shift(1)
    ticker_df['Ticker_Above_DC20'] = ticker_df['Close'] > ticker_df['DC20_High']
    
    # åˆä½µ Nasdaq æŒ‡æ¨™åˆ°å€‹è‚¡è³‡æ–™
    nasdaq_cols = ['Nasdaq_120MA', 'Nasdaq_Above_120MA']
    for col in nasdaq_cols:
        ticker_df[col] = benchmark_df[col].reindex(ticker_df.index).ffill()
    
    # æ·»åŠ  Nasdaq Close
    ticker_df['Nasdaq_Close'] = benchmark_df['Close'].reindex(ticker_df.index).ffill()
    
    return ticker_df


def check_entry_condition(row: pd.Series) -> tuple:
    """æª¢æŸ¥é€²å ´æ¢ä»¶"""
    nasdaq_above_ma = row.get('Nasdaq_Above_120MA', False)
    ticker_above_dc = row.get('Ticker_Above_DC20', False)
    
    if nasdaq_above_ma:
        return True, "bull_market"
    
    if not nasdaq_above_ma and ticker_above_dc:
        return True, "breakout"
    
    return False, "blocked"


# =============================================================================
# å›æ¸¬å¼•æ“
# =============================================================================
class NVDAFollowBacktester:
    """NVDA è·Ÿå–®å›æ¸¬å™¨"""
    
    def __init__(self, yearly_injection: float = YEARLY_INJECTION):
        self.yearly_injection = yearly_injection
        self.capital_pool = 0.0  # è³‡é‡‘æ± 
        self.positions = []      # æŒå€‰åˆ—è¡¨
        self.trades = []         # äº¤æ˜“ç´€éŒ„
        self.equity_curve = []   # æ·¨å€¼æ›²ç·š
        self.injection_log = []  # æ³¨å…¥ç´€éŒ„
        self.buy_signals = []    # è²·å…¥è¨Šè™Ÿ
        self.sell_signals = []   # è³£å‡ºè¨Šè™Ÿ
        self.blocked_signals = []  # è¢«æ¿¾ç¶²æ“‹ä½çš„è¨Šè™Ÿ
    
    def run(self, model: PPO, features_df: pd.DataFrame, 
            benchmark_df: pd.DataFrame, start_date: str, end_date: str) -> dict:
        """åŸ·è¡Œå›æ¸¬"""
        # æº–å‚™å¸‚å ´æ¿¾ç¶²
        test_df = prepare_market_filter(benchmark_df, features_df)
        
        # éæ¿¾æ¸¬è©¦æœŸé–“
        test_df = test_df[
            (test_df.index >= pd.Timestamp(start_date)) &
            (test_df.index <= pd.Timestamp(end_date))
        ].copy()
        
        if len(test_df) == 0:
            return None
        
        dates = test_df.index.tolist()
        closes = test_df['Close'].values
        features = test_df[FEATURE_COLS].values.astype(np.float32)
        
        # åˆå§‹åŒ–: èµ·å§‹æ—¥æ³¨å…¥è³‡é‡‘
        self.capital_pool = self.yearly_injection
        self.injection_log.append({'date': dates[0], 'amount': self.yearly_injection, 'type': 'initial'})
        
        current_year = dates[0].year
        year_first_day_processed = {current_year: True}  # èµ·å§‹å¹´å·²è™•ç†
        
        for i in tqdm(range(len(test_df)), desc=f"  Backtesting {TICKER}", leave=False):
            date = dates[i]
            price = closes[i]
            row = test_df.iloc[i]
            
            # =====================================================================
            # æ¯å¹´ç¬¬ä¸€å€‹äº¤æ˜“æ—¥æ³¨å…¥è³‡é‡‘
            # =====================================================================
            if date.year != current_year:
                current_year = date.year
                if current_year not in year_first_day_processed:
                    self.capital_pool += self.yearly_injection
                    self.injection_log.append({
                        'date': date, 
                        'amount': self.yearly_injection, 
                        'type': 'yearly'
                    })
                    year_first_day_processed[current_year] = True
            
            # =====================================================================
            # è¨ˆç®—ç•¶å‰æ·¨å€¼
            # =====================================================================
            position_value = sum(p['shares'] * price for p in self.positions)
            current_value = self.capital_pool + position_value
            self.equity_curve.append({
                'date': date, 
                'value': current_value,
                'capital_pool': self.capital_pool,
                'position_value': position_value
            })
            
            # =====================================================================
            # æŒå€‰ç®¡ç†: æª¢æŸ¥å‡ºå ´æ¢ä»¶
            # =====================================================================
            positions_to_remove = []
            for idx, pos in enumerate(self.positions):
                buy_price = pos['buy_price']
                current_return = price / buy_price - 1
                highest_return = pos['highest_price'] / buy_price - 1
                drawdown_from_high = (pos['highest_price'] - price) / pos['highest_price']
                
                # æ›´æ–°æœ€é«˜åƒ¹
                if price > pos['highest_price']:
                    pos['highest_price'] = price
                
                sell_reason = None
                
                # ç¡¬æ€§åœæ
                if current_return <= HARD_STOP_PCT:
                    sell_reason = "Hard Stop"
                # ç§»å‹•åœåˆ©
                elif highest_return >= TRAILING_ACTIVATION:
                    cb_limit = CALLBACK_HIGH if highest_return >= HIGH_PROFIT_THR else CALLBACK_BASE
                    if drawdown_from_high >= cb_limit:
                        sell_reason = "Trailing Stop"
                
                if sell_reason:
                    sell_value = pos['shares'] * price
                    profit = sell_value - pos['cost']
                    self.capital_pool += sell_value  # è³‡é‡‘å›æµ
                    
                    self.trades.append({
                        'buy_date': pos['buy_date'],
                        'buy_price': buy_price,
                        'sell_date': date,
                        'sell_price': price,
                        'shares': pos['shares'],
                        'cost': pos['cost'],
                        'sell_value': sell_value,
                        'return': current_return,
                        'profit': profit,
                        'hold_days': (date - pos['buy_date']).days,
                        'exit_reason': sell_reason,
                        'entry_type': pos['entry_type'],
                        'confidence': pos['confidence']
                    })
                    self.sell_signals.append((date, price, sell_reason))
                    positions_to_remove.append(idx)
            
            # ç§»é™¤å·²å¹³å€‰çš„éƒ¨ä½
            for idx in sorted(positions_to_remove, reverse=True):
                self.positions.pop(idx)
            
            # =====================================================================
            # é€²å ´: æª¢æŸ¥ AI è²·å…¥ä¿¡è™Ÿ
            # =====================================================================
            obs = features[i]
            action, confidence = get_action_confidence(model, obs)
            
            if action == 1:  # Agent ç™¼å‡ºè²·å…¥ä¿¡è™Ÿ
                # æª¢æŸ¥å¸‚å ´æ¿¾ç¶²
                allow_entry, entry_type = check_entry_condition(row)
                
                if allow_entry:
                    # æ ¹æ“šä¿¡å¿ƒåº¦æ±ºå®šè²·å…¥æ¯”ä¾‹
                    if confidence > CONFIDENCE_HIGH:
                        buy_ratio = BUY_RATIO_HIGH
                    elif confidence >= CONFIDENCE_LOW:
                        buy_ratio = BUY_RATIO_LOW
                    else:
                        buy_ratio = 0  # ä¸è²·å…¥
                    
                    if buy_ratio > 0 and self.capital_pool > 0:
                        invest_amount = self.capital_pool * buy_ratio
                        
                        # è·³éç„¡æ³•è²·åˆ°1è‚¡çš„æƒ…æ³ (é¿å…ç”¢ç”Ÿç„¡æ„ç¾©çš„å€‰ä½)
                        if invest_amount < price:
                            continue
                        
                        shares = invest_amount / price  # å…è¨±å°æ•¸è‚¡
                        
                        if shares > 0:
                            cost = shares * price
                            self.capital_pool -= cost
                            
                            self.positions.append({
                                'shares': shares,
                                'buy_price': price,
                                'buy_date': date,
                                'cost': cost,
                                'highest_price': price,
                                'confidence': confidence,
                                'entry_type': entry_type
                            })
                            self.buy_signals.append((date, price, entry_type, confidence, buy_ratio))
                    elif confidence < CONFIDENCE_LOW:
                        self.blocked_signals.append((date, price, confidence, 'low_confidence'))
                else:
                    self.blocked_signals.append((date, price, confidence, 'filter_blocked'))
        
        # å›æ¸¬çµæŸæ™‚çš„æœ€å¾Œç‹€æ…‹
        final_date = dates[-1]
        final_price = closes[-1]
        final_row = test_df.iloc[-1]
        
        return self._generate_results(test_df, final_date, final_price, final_row, model, features[-1])
    
    def _generate_results(self, test_df: pd.DataFrame, final_date, final_price, final_row, model, final_obs) -> dict:
        """ç”Ÿæˆå›æ¸¬çµæœ"""
        if not self.equity_curve:
            return None
        
        equity_df = pd.DataFrame(self.equity_curve)
        equity_df['date'] = pd.to_datetime(equity_df['date'])
        equity_df.set_index('date', inplace=True)
        
        # è¨ˆç®—ç¸½æ³¨å…¥é‡‘é¡
        total_injected = sum(log['amount'] for log in self.injection_log)
        
        # æœ€çµ‚æ·¨å€¼
        position_value = sum(p['shares'] * final_price for p in self.positions)
        final_value = self.capital_pool + position_value
        total_return = (final_value - total_injected) / total_injected
        
        # è¨ˆç®—å¹´åŒ–å ±é…¬
        days = (equity_df.index[-1] - equity_df.index[0]).days
        years = days / 365.0
        cagr = (final_value / total_injected) ** (1 / years) - 1 if years > 0 else 0
        
        # Sharpe Ratio
        daily_returns = equity_df['value'].pct_change().dropna()
        if len(daily_returns) > 0 and daily_returns.std() > 0:
            sharpe = (daily_returns.mean() * 252 - 0.02) / (daily_returns.std() * np.sqrt(252))
        else:
            sharpe = 0
        
        # Maximum Drawdown
        rolling_max = equity_df['value'].cummax()
        drawdown = (equity_df['value'] - rolling_max) / rolling_max
        max_drawdown = drawdown.min()
        
        # å‹ç‡
        if self.trades:
            wins = sum(1 for t in self.trades if t['return'] > 0)
            win_rate = wins / len(self.trades)
        else:
            win_rate = 0
        
        # ç²å–æœ€å¾Œä¸€å¤©çš„ AI ä¿¡è™Ÿ
        final_action, final_confidence = get_action_confidence(model, final_obs)
        allow_entry, entry_type = check_entry_condition(final_row)
        
        return {
            'ticker': TICKER,
            'total_injected': total_injected,
            'final_value': final_value,
            'capital_pool': self.capital_pool,
            'position_value': position_value,
            'total_return': total_return,
            'cagr': cagr,
            'sharpe_ratio': sharpe,
            'max_drawdown': max_drawdown,
            'total_trades': len(self.trades),
            'win_rate': win_rate,
            'injection_count': len(self.injection_log),
            'equity_df': equity_df,
            'positions': self.positions.copy(),
            'trades': self.trades.copy(),
            'buy_signals': self.buy_signals.copy(),
            'sell_signals': self.sell_signals.copy(),
            'blocked_signals': self.blocked_signals.copy(),
            'injection_log': self.injection_log.copy(),
            'test_start': test_df.index[0],
            'test_end': test_df.index[-1],
            'final_date': final_date,
            'final_price': final_price,
            'final_row': final_row,
            'final_action': final_action,
            'final_confidence': final_confidence,
            'final_allow_entry': allow_entry,
            'final_entry_type': entry_type
        }


# =============================================================================
# Benchmark: Nasdaq Buy & Hold (åŒç­‰è³‡é‡‘æ³¨å…¥)
# =============================================================================
def calculate_nasdaq_benchmark(benchmark_df: pd.DataFrame, start_date: str, end_date: str) -> dict:
    """è¨ˆç®— Nasdaq è²·å…¥æŒæœ‰çš„åŸºæº– (åŒç­‰å¹´åº¦è³‡é‡‘æ³¨å…¥)"""
    test_df = benchmark_df[
        (benchmark_df.index >= pd.Timestamp(start_date)) &
        (benchmark_df.index <= pd.Timestamp(end_date))
    ].copy()
    
    if len(test_df) == 0:
        return None
    
    dates = test_df.index.tolist()
    closes = test_df['Close'].values
    
    # åŒæ¨£çš„è³‡é‡‘æ³¨å…¥é‚è¼¯
    total_shares = 0.0
    total_invested = 0.0
    equity_curve = []
    
    current_year = dates[0].year
    year_first_day_processed = {current_year: True}
    
    # åˆå§‹æ³¨å…¥
    initial_price = closes[0]
    initial_shares = YEARLY_INJECTION / initial_price
    total_shares += initial_shares
    total_invested += YEARLY_INJECTION
    
    for i, (date, price) in enumerate(zip(dates, closes)):
        # æ¯å¹´ç¬¬ä¸€å€‹äº¤æ˜“æ—¥æ³¨å…¥
        if date.year != current_year:
            current_year = date.year
            if current_year not in year_first_day_processed:
                new_shares = YEARLY_INJECTION / price
                total_shares += new_shares
                total_invested += YEARLY_INJECTION
                year_first_day_processed[current_year] = True
        
        current_value = total_shares * price
        equity_curve.append({'date': date, 'value': current_value})
    
    equity_df = pd.DataFrame(equity_curve)
    equity_df['date'] = pd.to_datetime(equity_df['date'])
    equity_df.set_index('date', inplace=True)
    
    final_value = total_shares * closes[-1]
    total_return = (final_value - total_invested) / total_invested
    
    days = (dates[-1] - dates[0]).days
    years = days / 365.0
    cagr = (final_value / total_invested) ** (1 / years) - 1 if years > 0 else 0
    
    daily_returns = equity_df['value'].pct_change().dropna()
    if len(daily_returns) > 0 and daily_returns.std() > 0:
        sharpe = (daily_returns.mean() * 252 - 0.02) / (daily_returns.std() * np.sqrt(252))
    else:
        sharpe = 0
    
    rolling_max = equity_df['value'].cummax()
    drawdown = (equity_df['value'] - rolling_max) / rolling_max
    max_drawdown = drawdown.min()
    
    return {
        'ticker': '^IXIC (Nasdaq B&H)',
        'total_invested': total_invested,
        'final_value': final_value,
        'total_return': total_return,
        'cagr': cagr,
        'sharpe_ratio': sharpe,
        'max_drawdown': max_drawdown,
        'equity_df': equity_df
    }


# =============================================================================
# è¼¸å‡º: End Date Summary
# =============================================================================
def generate_end_date_summary(result: dict, benchmark: dict, output_dir: str, 
                               start_date: str, end_date: str):
    """ç”Ÿæˆå›æ¸¬æœ€å¾Œä¸€å¤©çš„è·Ÿå–®ç¸½çµ"""
    start_short = start_date.replace('-', '')
    end_short = end_date.replace('-', '')
    filename = f"end_date_summary_NVDA_{start_short}_{end_short}.txt"
    filepath = os.path.join(output_dir, filename)
    
    final_date = result['final_date']
    final_price = result['final_price']
    final_row = result['final_row']
    positions = result['positions']
    capital_pool = result['capital_pool']
    
    lines = []
    lines.append("=" * 60)
    lines.append(f"ğŸ“… å ±å‘Šæ—¥æœŸ: {final_date.strftime('%Y-%m-%d')}")
    lines.append("=" * 60)
    
    # å¸‚å ´æ•¸æ“š
    lines.append("[å¸‚å ´æ•¸æ“š - NVDA]")
    lines.append(f"ğŸ“Š Close: ${final_price:.2f}")
    lines.append("-" * 30)
    lines.append("[å¸‚å ´æ•¸æ“š - Nasdaq]")
    lines.append(f"ğŸ“Š Close: {final_row.get('Nasdaq_Close', 'N/A'):.2f}")
    lines.append(f"   120MA: {final_row.get('Nasdaq_120MA', 'N/A'):.2f}")
    lines.append(f"   Close > 120MA: {'âœ… YES' if final_row.get('Nasdaq_Above_120MA', False) else 'âŒ NO'}")
    lines.append("-" * 30)
    
    # æ¿¾ç¶²èˆ‡ AI ä¿¡è™Ÿ
    lines.append("[æ¿¾ç¶²èˆ‡ AI ä¿¡è™Ÿ]")
    allow_entry = result['final_allow_entry']
    entry_type = result['final_entry_type']
    action = result['final_action']
    confidence = result['final_confidence']
    
    action_str = "BUY" if action == 1 else "WAIT"
    lines.append(f"   ğŸ¤– AI Action: {action_str} (Conf: {confidence*100:.1f}%)")
    lines.append(f"   ğŸ“Š é€²å ´å…è¨±: {'âœ… YES' if allow_entry else 'âŒ NO'} ({entry_type})")
    lines.append("-" * 50)
    
    # å¸³æˆ¶ç‹€æ…‹
    position_value = sum(p['shares'] * final_price for p in positions)
    total_value = capital_pool + position_value
    total_injected = result['total_injected']
    unrealized_pnl = position_value - sum(p['cost'] for p in positions) if positions else 0
    unrealized_pct = unrealized_pnl / sum(p['cost'] for p in positions) * 100 if positions else 0
    
    lines.append("[å¸³æˆ¶ç‹€æ…‹]")
    lines.append(f"   ğŸ’µ è³‡é‡‘æ± é¤˜é¡ (Cash):  ${capital_pool:,.2f}")
    lines.append(f"   ğŸ’ æŒå€‰å¸‚å€¼ (Value):   ${position_value:,.2f}")
    lines.append(f"   ğŸ¦ ç¸½è³‡ç”¢ (Total):     ${total_value:,.2f}")
    lines.append(f"   ğŸ“ˆ æœªå¯¦ç¾æç›Š:         ${unrealized_pnl:,.2f} ({unrealized_pct:+.2f}%)")
    lines.append(f"   ğŸ’° ç´¯è¨ˆæ³¨å…¥:           ${total_injected:,.2f}")
    lines.append(f"   ğŸ“Š ç¸½å ±é…¬ç‡:           {result['total_return']*100:+.2f}%")
    lines.append("-" * 50)
    
    # æŒå€‰æ˜ç´°
    lines.append(f"[æŒå€‰æ˜ç´°] (å…± {len(positions)} å€‰)")
    for idx, pos in enumerate(positions, 1):
        buy_date = pos['buy_date'].strftime('%Y-%m-%d')
        buy_price = pos['buy_price']
        cost = pos['cost']
        shares = pos['shares']
        current_value = shares * final_price
        ret = (final_price / buy_price - 1) * 100
        highest = pos['highest_price']
        conf = pos['confidence']
        
        lines.append(f"   #{idx} è²·å…¥: {buy_date} @ ${buy_price:.2f} (ä¿¡å¿ƒ: {conf*100:.1f}%)")
        lines.append(f"       è‚¡æ•¸: {shares:.4f} | æˆæœ¬: ${cost:,.2f} | å¸‚å€¼: ${current_value:,.2f}")
        lines.append(f"       å ±é…¬: {ret:+.2f}% | æœ€é«˜åƒ¹: ${highest:.2f}")
        
        # åœæåœåˆ©åƒ¹ä½
        hard_stop_price = buy_price * (1 + HARD_STOP_PCT)
        trailing_trigger_price = buy_price * (1 + TRAILING_ACTIVATION)
        lines.append(f"       ğŸ›‘ ç¡¬æ€§åœæ: ${hard_stop_price:.2f}")
        
        highest_return = highest / buy_price - 1
        if highest_return >= TRAILING_ACTIVATION:
            cb_limit = CALLBACK_HIGH if highest_return >= HIGH_PROFIT_THR else CALLBACK_BASE
            trailing_stop_price = highest * (1 - cb_limit)
            lines.append(f"       ğŸ“‰ ç§»å‹•åœåˆ©: ${trailing_stop_price:.2f} (å›æª” {cb_limit*100:.0f}%)")
        else:
            lines.append(f"       ğŸ“‰ ç§»å‹•åœåˆ©: (æœªå•Ÿå‹•, éœ€æ¼²è‡³ ${trailing_trigger_price:.2f})")
        lines.append("")
    
    lines.append("-" * 50)
    
    # æ˜æ—¥äº¤æ˜“å»ºè­°
    lines.append("[ğŸ”® æ˜æ—¥äº¤æ˜“å»ºè­° - é–‹ç›¤åŸ·è¡Œ]")
    lines.append("")
    
    # è²·å…¥å»ºè­°
    if action == 1 and allow_entry:
        if confidence > CONFIDENCE_HIGH:
            buy_ratio = BUY_RATIO_HIGH
            ratio_desc = ">95%"
        elif confidence >= CONFIDENCE_LOW:
            buy_ratio = BUY_RATIO_LOW
            ratio_desc = "90%-95%"
        else:
            buy_ratio = 0
            ratio_desc = "<90%"
        
        if buy_ratio > 0 and capital_pool > 0:
            buy_amount = capital_pool * buy_ratio
            lines.append(f"   ğŸ“ˆ ã€è²·å…¥å»ºè­°ã€‘: âœ… å»ºè­°è²·å…¥")
            lines.append(f"      ğŸ’° å»ºè­°è²·å…¥é‡‘é¡: ${buy_amount:,.2f}")
            lines.append(f"      ğŸ“Š è³‡é‡‘æ¯”ä¾‹: {buy_ratio*100:.0f}% (AI ä¿¡å¿ƒåº¦ {ratio_desc})")
            lines.append(f"      ğŸ’µ è³‡é‡‘æ± é¤˜é¡: ${capital_pool:,.2f}")
        else:
            lines.append(f"   ğŸ“ˆ ã€è²·å…¥å»ºè­°ã€‘: âŒ ä¸å»ºè­°è²·å…¥")
            lines.append(f"      âš ï¸ åŸå› : ä¿¡å¿ƒåº¦ä¸è¶³ ({confidence*100:.1f}% < 90%)")
    else:
        lines.append(f"   ğŸ“ˆ ã€è²·å…¥å»ºè­°ã€‘: âŒ ä¸å»ºè­°è²·å…¥")
        if action != 1:
            lines.append(f"      âš ï¸ åŸå› : AI æœªç™¼å‡ºè²·å…¥ä¿¡è™Ÿ")
        elif not allow_entry:
            lines.append(f"      âš ï¸ åŸå› : å¸‚å ´æ¿¾ç¶²é˜»æ“‹ ({entry_type})")
    
    lines.append("")
    lines.append("-" * 30)
    lines.append("")
    
    # è³£å‡ºç›£æ§
    lines.append("   ğŸ“‰ ã€è³£å‡ºç›£æ§ã€‘: åœæ/åœåˆ©è§¸ç™¼åƒ¹ä½")
    lines.append("")
    for idx, pos in enumerate(positions, 1):
        buy_price = pos['buy_price']
        shares = pos['shares']
        current_value = shares * final_price
        highest = pos['highest_price']
        
        hard_stop_price = buy_price * (1 + HARD_STOP_PCT)
        hard_stop_value = shares * hard_stop_price
        
        lines.append(f"      #å€‰{idx} (å¸‚å€¼ ${current_value:,.2f}):")
        lines.append(f"         ğŸ›‘ ç¡¬åœæè§¸ç™¼: NVDA è·Œè‡³ ${hard_stop_price:.2f} æ™‚è³£å‡º")
        lines.append(f"            â†’ é è¨ˆæ”¶å›: ${hard_stop_value:,.2f}")
        
        highest_return = highest / buy_price - 1
        if highest_return >= TRAILING_ACTIVATION:
            cb_limit = CALLBACK_HIGH if highest_return >= HIGH_PROFIT_THR else CALLBACK_BASE
            trailing_stop_price = highest * (1 - cb_limit)
            trailing_value = shares * trailing_stop_price
            lines.append(f"         ğŸ“‰ ç§»å‹•åœåˆ©: NVDA è·Œè‡³ ${trailing_stop_price:.2f} æ™‚è³£å‡º")
            lines.append(f"            â†’ é è¨ˆæ”¶å›: ${trailing_value:,.2f}")
        else:
            lines.append(f"         ğŸ“‰ ç§»å‹•åœåˆ©: æœªå•Ÿå‹• (éœ€æ¼² {TRAILING_ACTIVATION*100:.0f}%)")
        lines.append("")
    
    lines.append("=" * 60)
    lines.append("ğŸ“Š ç¸¾æ•ˆæ‘˜è¦")
    lines.append("=" * 60)
    lines.append(f"   ç­–ç•¥ (NVDA AI Follow):")
    lines.append(f"      ç¸½å ±é…¬: {result['total_return']*100:+.2f}%")
    lines.append(f"      CAGR: {result['cagr']*100:.2f}%")
    lines.append(f"      Sharpe: {result['sharpe_ratio']:.2f}")
    lines.append(f"      MDD: {result['max_drawdown']*100:.2f}%")
    lines.append(f"      äº¤æ˜“æ¬¡æ•¸: {result['total_trades']}")
    lines.append(f"      å‹ç‡: {result['win_rate']*100:.1f}%")
    lines.append("")
    
    if benchmark:
        lines.append(f"   åŸºæº– (Nasdaq B&H):")
        lines.append(f"      ç¸½å ±é…¬: {benchmark['total_return']*100:+.2f}%")
        lines.append(f"      CAGR: {benchmark['cagr']*100:.2f}%")
        lines.append(f"      Sharpe: {benchmark['sharpe_ratio']:.2f}")
        lines.append(f"      MDD: {benchmark['max_drawdown']*100:.2f}%")
    
    lines.append("=" * 60)
    
    with open(filepath, 'w', encoding='utf-8') as f:
        f.write('\n'.join(lines))
    
    print(f"âœ… è·Ÿå–®ç¸½çµå·²å„²å­˜: {filepath}")
    return filepath


# =============================================================================
# è¦–è¦ºåŒ–
# =============================================================================
def plot_equity_curve(result: dict, benchmark: dict, output_dir: str,
                      start_date: str, end_date: str):
    """ç¹ªè£½æ·¨å€¼æ›²ç·š"""
    fig, ax = plt.subplots(figsize=(14, 8))
    
    # ç­–ç•¥æ·¨å€¼
    equity_df = result['equity_df']
    ax.plot(equity_df.index, equity_df['value'], 
            label=f"NVDA AI Follow ({result['total_return']:.0%})",
            linewidth=2, color='#4CAF50')
    
    # Benchmark
    if benchmark:
        bench_equity = benchmark['equity_df']
        ax.plot(bench_equity.index, bench_equity['value'],
                label=f"Nasdaq B&H ({benchmark['total_return']:.0%})",
                linewidth=2, linestyle='--', color='gray')
    
    # è³‡é‡‘æ³¨å…¥æ¨™è¨˜
    for log in result['injection_log']:
        ax.axvline(x=log['date'], color='blue', linestyle=':', alpha=0.5)
    
    # è²·å…¥è¨Šè™Ÿ
    if result['buy_signals']:
        buy_dates = [s[0] for s in result['buy_signals']]
        # æ‰¾åˆ°å°æ‡‰çš„ equity å€¼
        buy_values = [equity_df.loc[d, 'value'] if d in equity_df.index else None for d in buy_dates]
        valid = [(d, v) for d, v in zip(buy_dates, buy_values) if v is not None]
        if valid:
            dates, values = zip(*valid)
            ax.scatter(dates, values, marker='^', color='green', s=80, zorder=5, label='Buy')
    
    # è³£å‡ºè¨Šè™Ÿ
    if result['sell_signals']:
        sell_dates = [s[0] for s in result['sell_signals']]
        sell_values = [equity_df.loc[d, 'value'] if d in equity_df.index else None for d in sell_dates]
        valid = [(d, v) for d, v in zip(sell_dates, sell_values) if v is not None]
        if valid:
            dates, values = zip(*valid)
            ax.scatter(dates, values, marker='v', color='red', s=80, zorder=5, label='Sell')
    
    ax.axhline(y=result['total_injected'], color='black', linestyle=':', alpha=0.3, 
               label=f"Total Injected (${result['total_injected']:,.0f})")
    
    ax.set_title(f'NVDA AI Follow ç­–ç•¥æ·¨å€¼æ›²ç·š\n{start_date} ~ {end_date}', fontsize=14)
    ax.set_xlabel('Date')
    ax.set_ylabel('Portfolio Value ($)')
    ax.legend(loc='upper left', fontsize=10)
    ax.grid(True, alpha=0.3)
    ax.set_ylim(bottom=0)
    
    plt.tight_layout()
    chart_path = os.path.join(output_dir, "equity_curve_nvda_follow.png")
    plt.savefig(chart_path, dpi=150, bbox_inches='tight')
    plt.close()
    print(f"âœ… æ·¨å€¼æ›²ç·šå·²å„²å­˜: {chart_path}")


def save_trade_log(result: dict, output_dir: str, start_date: str, end_date: str):
    """å„²å­˜äº¤æ˜“ç´€éŒ„"""
    if not result['trades']:
        print("âš ï¸ ç„¡äº¤æ˜“ç´€éŒ„")
        return
    
    trades_df = pd.DataFrame(result['trades'])
    start_short = start_date.replace('-', '')
    end_short = end_date.replace('-', '')
    filename = f"trade_log_NVDA_{start_short}_{end_short}.csv"
    filepath = os.path.join(output_dir, filename)
    trades_df.to_csv(filepath, index=False, encoding='utf-8-sig')
    print(f"âœ… äº¤æ˜“ç´€éŒ„å·²å„²å­˜: {filepath}")


# =============================================================================
# å‘½ä»¤åˆ—åƒæ•¸
# =============================================================================
def parse_args():
    parser = argparse.ArgumentParser(description='NVDA å°ˆå±¬è·Ÿå–®å›æ¸¬è…³æœ¬')
    parser.add_argument('--start', type=str, default=DEFAULT_START,
                        help=f'å›æ¸¬èµ·å§‹æ—¥æœŸ (é è¨­: {DEFAULT_START})')
    parser.add_argument('--end', type=str, default=DEFAULT_END,
                        help=f'å›æ¸¬çµæŸæ—¥æœŸ (é è¨­: {DEFAULT_END})')
    return parser.parse_args()


# =============================================================================
# ä¸»ç¨‹å¼
# =============================================================================
def main():
    args = parse_args()
    start_date = args.start
    end_date = args.end
    
    # æ—¥æœŸé©—è­‰ï¼šå¦‚æœèµ·å§‹æ—¥æ™šæ–¼çµæŸæ—¥ï¼Œå°‡çµæŸæ—¥è¨­ç‚ºä»Šå¤©
    if pd.Timestamp(start_date) > pd.Timestamp(end_date):
        end_date = datetime.now().strftime('%Y-%m-%d')
        print(f"âš ï¸  èµ·å§‹æ—¥æ™šæ–¼é è¨­çµæŸæ—¥ï¼Œè‡ªå‹•å°‡çµæŸæ—¥è¨­ç‚ºä»Šå¤©: {end_date}")
    
    # å‹•æ…‹è¼¸å‡ºç›®éŒ„ (æ”¾åœ¨å°ˆå±¬ç›®éŒ„å…§ï¼ŒæŒ‰æ—¥æœŸå€åˆ†)
    start_short = start_date.replace('-', '')
    end_short = end_date.replace('-', '')
    output_dir = os.path.join(BASE_OUTPUT_DIR, f"{start_short}_{end_short}")
    
    print("=" * 70)
    print("  NVDA å°ˆå±¬è·Ÿå–®å›æ¸¬")
    print(f"  æœŸé–“: {start_date} ~ {end_date}")
    print(f"  è³‡é‡‘æ³¨å…¥: ${YEARLY_INJECTION:,}/å¹´")
    print(f"  ä¿¡å¿ƒåº¦é–€æª»: >{CONFIDENCE_HIGH*100:.0f}%â†’{BUY_RATIO_HIGH*100:.0f}%, "
          f"{CONFIDENCE_LOW*100:.0f}%-{CONFIDENCE_HIGH*100:.0f}%â†’{BUY_RATIO_LOW*100:.0f}%")
    print(f"  è¼¸å‡º: {output_dir}/")
    print("=" * 70)
    
    os.makedirs(output_dir, exist_ok=True)
    
    # è¼‰å…¥æ¨¡å‹
    print("\n[Step 1] è¼‰å…¥æ¨¡å‹...")
    manifest = load_model_manifest(MODELS_PATH)
    if manifest is None:
        print("âŒ ç„¡æ³•è¼‰å…¥ manifest")
        return
    
    model = load_ticker_model(TICKER, manifest)
    if model is None:
        print(f"âŒ ç„¡æ³•è¼‰å…¥ {TICKER} æ¨¡å‹")
        return
    print(f"âœ… {TICKER} æ¨¡å‹è¼‰å…¥æˆåŠŸ")
    
    # è¼‰å…¥æ•¸æ“š
    print("\n[Step 2] è¼‰å…¥æ•¸æ“š...")
    benchmark_df = load_or_update_local_csv(BENCHMARK)
    if benchmark_df is None:
        print("âŒ ç„¡æ³•è¼‰å…¥åŸºæº–æŒ‡æ•¸")
        return
    
    raw_df = load_or_update_local_csv(TICKER)
    if raw_df is None:
        print(f"âŒ ç„¡æ³•è¼‰å…¥ {TICKER} æ•¸æ“š")
        return
    
    features_df = calculate_features(raw_df, benchmark_df, TICKER, use_cache=True)
    print(f"âœ… æ•¸æ“šè¼‰å…¥å®Œæˆ")
    
    # è¨ˆç®— Benchmark
    print("\n[Step 3] è¨ˆç®— Nasdaq Benchmark...")
    benchmark = calculate_nasdaq_benchmark(benchmark_df, start_date, end_date)
    if benchmark:
        print(f"   Nasdaq B&H: Return={benchmark['total_return']:.1%} | CAGR={benchmark['cagr']:.1%}")
    
    # åŸ·è¡Œå›æ¸¬
    print("\n[Step 4] åŸ·è¡Œå›æ¸¬...")
    backtester = NVDAFollowBacktester(YEARLY_INJECTION)
    result = backtester.run(model, features_df, benchmark_df, start_date, end_date)
    
    if result is None:
        print("âŒ å›æ¸¬å¤±æ•—")
        return
    
    # è¼¸å‡ºçµæœ
    print("\n[Step 5] è¼¸å‡ºçµæœ...")
    
    print("\n" + "=" * 70)
    print("ğŸ“Š å›æ¸¬ç¸¾æ•ˆ")
    print("=" * 70)
    print(f"   {'æŒ‡æ¨™':<20} | {'NVDA AI Follow':<20} | {'Nasdaq B&H':<20}")
    print("-" * 70)
    print(f"   {'ç¸½å ±é…¬':<20} | {result['total_return']:>18.1%} | {benchmark['total_return'] if benchmark else 'N/A':>18.1%}")
    print(f"   {'CAGR':<20} | {result['cagr']:>18.1%} | {benchmark['cagr'] if benchmark else 'N/A':>18.1%}")
    print(f"   {'Sharpe Ratio':<20} | {result['sharpe_ratio']:>18.2f} | {benchmark['sharpe_ratio'] if benchmark else 'N/A':>18.2f}")
    print(f"   {'Max Drawdown':<20} | {result['max_drawdown']:>18.1%} | {benchmark['max_drawdown'] if benchmark else 'N/A':>18.1%}")
    print(f"   {'äº¤æ˜“æ¬¡æ•¸':<20} | {result['total_trades']:>18} | {'N/A':>18}")
    print(f"   {'å‹ç‡':<20} | {result['win_rate']:>18.1%} | {'N/A':>18}")
    print("=" * 70)
    
    generate_end_date_summary(result, benchmark, output_dir, start_date, end_date)
    plot_equity_curve(result, benchmark, output_dir, start_date, end_date)
    save_trade_log(result, output_dir, start_date, end_date)
    
    print("\n" + "=" * 70)
    print("  âœ… å›æ¸¬å®Œæˆï¼")
    print(f"  ğŸ“ çµæœå„²å­˜æ–¼: {output_dir}/")
    print("=" * 70)


if __name__ == "__main__":
    main()
